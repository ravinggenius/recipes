// Generated by CoffeeScript 1.3.1
var View, addId, bindEvents, bindEventsById, bindEventsByIdString, blockFn, boundMacroName, ctxPath, dataValue, defaultCtx, defaultGetFns, defaultSetFns, empty, escapeAttr, escapeHtml, extend, extendCtx, extractPlaceholder, isBound, isVoid, keyHash, markup, modelListener, notFound, objectToString, onBlock, parse, parseAttr, parseHtml, parseMarkup, parseMatch, parseMatchError, parsePartialAttr, partialFn, partialName, partialValue, patchCtx, pathFnArgs, pushChars, pushVar, pushVarFn, pushVarString, reduceStack, renderer, sectionFn, textFn, trim, unescapeEntities, wrapRemainder, _ref, _ref1;

_ref = require('./html'), parseHtml = _ref.parse, unescapeEntities = _ref.unescapeEntities, escapeHtml = _ref.escapeHtml, escapeAttr = _ref.escapeAttr, isVoid = _ref.isVoid;

markup = require('./markup');

_ref1 = require('./viewPath'), trim = _ref1.trim, wrapRemainder = _ref1.wrapRemainder, ctxPath = _ref1.ctxPath, extractPlaceholder = _ref1.extractPlaceholder, dataValue = _ref1.dataValue, pathFnArgs = _ref1.pathFnArgs;

empty = function() {
  return '';
};

notFound = function(name, ns) {
  if (ns) {
    name = ns + ':' + name;
  }
  throw new Error("Can't find view: " + name);
};

defaultCtx = {
  $depth: 0,
  $aliases: {},
  $paths: [],
  $indices: []
};

defaultGetFns = {
  equal: function(a, b) {
    return a === b;
  },
  not: function(value) {
    return !value;
  }
};

defaultSetFns = {
  equal: function(value, a) {
    if (value) {
      return [a];
    } else {
      return [];
    }
  },
  not: function(value) {
    return [!value];
  }
};

View = module.exports = function() {
  this.clear();
  this.getFns = Object.create(defaultGetFns);
  this.setFns = Object.create(defaultSetFns);
  this._componentNamespaces = {
    app: true
  };
  this._nonvoidComponents = {};
};

View.prototype = {
  clear: function() {
    this._views = Object.create(this["default"]);
    this._made = {};
    this._renders = {};
    this._inline = '';
    return this._idCount = 0;
  },
  _uniqueId: function() {
    return '$' + (this._idCount++).toString(36);
  },
  "default": {
    doctype: function() {
      return '<!DOCTYPE html>';
    },
    root: empty,
    charset: function() {
      return '<meta charset=utf-8>';
    },
    title$s: empty,
    head: empty,
    header: empty,
    body: empty,
    footer: empty,
    scripts: empty,
    tail: empty
  },
  make: function(name, template, options, templatePath, boundMacro) {
    var isString, onBind, render, renderer,
      _this = this;
    this._made[name] = [template, options, templatePath];
    if (options && 'nonvoid' in options) {
      this._nonvoidComponents[name] = true;
    }
    if (templatePath && (render = this._renders[templatePath])) {
      this._views[name] = render;
      return;
    }
    name = name.toLowerCase();
    if (name === 'title') {
      this.make('title$s', template, options, templatePath);
    } else if (name === 'title$s') {
      isString = true;
      onBind = function(events, name) {
        var macro;
        macro = false;
        return bindEvents(events, macro, name, render, ['$_doc', 'prop', 'title']);
      };
    }
    renderer = function(ctx) {
      renderer = parse(_this, name, template, isString, onBind, boundMacro);
      return renderer(ctx);
    };
    render = function(ctx) {
      return renderer(ctx);
    };
    this._views[name] = render;
    if (templatePath) {
      this._renders[templatePath] = render;
    }
  },
  _makeAll: function(templates, instances) {
    var name, options, templatePath, _ref2;
    for (name in instances) {
      _ref2 = instances[name], templatePath = _ref2[0], options = _ref2[1];
      this.make(name, templates[templatePath], options, templatePath);
    }
  },
  _findItem: function(name, ns, prop) {
    var from, i, item, items, segments, testNs, _i;
    items = this[prop];
    if (ns) {
      ns = ns.toLowerCase();
      if (item = items["" + ns + ":" + name]) {
        return item;
      }
      segments = ns.split(':');
      if ((from = segments.length - 2) >= 0) {
        for (i = _i = from; from <= 0 ? _i <= 0 : _i >= 0; i = from <= 0 ? ++_i : --_i) {
          testNs = segments.slice(0, i + 1 || 9e9).join(':');
          if (item = items["" + testNs + ":" + name]) {
            return item;
          }
        }
      }
      return items[name];
    }
    return items[name];
  },
  _find: function(name, ns, boundMacro) {
    var hash, hashedName, options, out, template, templatePath, _ref2;
    if (boundMacro && (hash = keyHash(boundMacro))) {
      hash = '$b:' + hash;
      hashedName = name + hash;
      if (out = this._findItem(hashedName, ns, '_views')) {
        return out;
      }
      _ref2 = this._findItem(name, ns, '_made') || notFound(name, ns), template = _ref2[0], options = _ref2[1], templatePath = _ref2[2];
      templatePath += hash;
      this.make(hashedName, template, options, templatePath, boundMacro);
      return this._find(hashedName, ns);
    }
    return this._findItem(name, ns, '_views') || notFound(name, ns);
  },
  get: function(name, ns, ctx) {
    if (typeof ns === 'object') {
      ctx = ns;
      ns = '';
    }
    ctx = ctx ? extend(ctx, defaultCtx) : Object.create(defaultCtx);
    return this._find(name, ns)(ctx);
  },
  inline: empty,
  fn: function(name, fn) {
    var get, set;
    if (typeof fn === 'object') {
      get = fn.get, set = fn.set;
    } else {
      get = fn;
    }
    this.getFns[name] = get;
    if (set) {
      return this.setFns[name] = set;
    }
  },
  render: function(model, ns, ctx, silent) {
    var attr, body, bodyHtml, doc, documentElement, fakeRoot, rootHtml, title, _i, _len, _ref2;
    this.model = model;
    if (typeof ns === 'object') {
      silent = ctx;
      ctx = ns;
      ns = '';
    }
    this._idCount = 0;
    this.model.__pathMap.clear();
    this.model.__events.clear();
    this.model.__blockPaths = {};
    this.dom.clear();
    title = this.get('title$s', ns, ctx);
    rootHtml = this.get('root', ns, ctx);
    bodyHtml = this.get('header', ns, ctx) + this.get('body', ns, ctx) + this.get('footer', ns, ctx);
    if (silent) {
      return;
    }
    doc = document;
    documentElement = doc.documentElement;
    _ref2 = documentElement.attributes;
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      attr = _ref2[_i];
      documentElement.removeAttribute(attr.name);
    }
    parseHtml(rootHtml, {
      start: function(tag, tagName, attrs) {
        var attr, value;
        if (tagName !== 'html') {
          return;
        }
        for (attr in attrs) {
          value = attrs[attr];
          documentElement.setAttribute(attr, value);
        }
      }
    });
    fakeRoot = doc.createElement('html');
    fakeRoot.innerHTML = bodyHtml;
    body = fakeRoot.getElementsByTagName('body')[0];
    documentElement.replaceChild(body, doc.body);
    return doc.title = title;
  },
  escapeHtml: escapeHtml,
  escapeAttr: escapeAttr
};

View.trim = trim;

keyHash = function(obj) {
  var key, keys;
  keys = [];
  for (key in obj) {
    keys.push(key);
  }
  return keys.sort().join(',');
};

extend = function(parent, obj) {
  var key, out;
  out = Object.create(parent);
  if (typeof obj !== 'object' || Array.isArray(obj)) {
    return out;
  }
  for (key in obj) {
    out[key] = obj[key];
  }
  return out;
};

modelListener = function(params, triggerId, blockPaths, pathId, partial, ctx) {
  var listener;
  listener = params.call ? params(triggerId, blockPaths, pathId) : params;
  listener.partial = partial;
  listener.ctx = ctx.$stringCtx || ctx;
  return listener;
};

bindEvents = function(events, macro, name, partial, params) {
  var args, bindName, i, match, prefix, relativeName, segments, _results;
  if (~name.indexOf('(')) {
    args = pathFnArgs(name);
    if (!args.length) {
      return;
    }
    events.push(function(ctx, modelEvents, dom, pathMap, view, blockPaths, triggerId) {
      var arg, listener, path, pathId, _i, _len;
      listener = modelListener(params, triggerId, blockPaths, null, partial, ctx);
      listener.getValue = function(model, triggerPath) {
        patchCtx(ctx, triggerPath);
        return dataValue(view, ctx, model, name, macro);
      };
      for (_i = 0, _len = args.length; _i < _len; _i++) {
        arg = args[_i];
        path = ctxPath(ctx, arg, macro);
        pathId = pathMap.id(path + '*');
        modelEvents.bind(pathId, listener);
      }
    });
    return;
  }
  match = /(\.*)(.*)/.exec(name);
  prefix = match[1] || '';
  relativeName = match[2] || '';
  segments = relativeName.split('.');
  i = segments.length + 1;
  _results = [];
  while (--i) {
    bindName = prefix + segments.slice(0, i).join('.');
    _results.push((function(bindName) {
      return events.push(function(ctx, modelEvents, dom, pathMap, view, blockPaths, triggerId) {
        var listener, path, pathId;
        if (!(path = ctxPath(ctx, name, macro))) {
          return;
        }
        pathId = pathMap.id(path);
        listener = modelListener(params, triggerId, blockPaths, pathId, partial, ctx);
        if (name !== bindName) {
          path = ctxPath(ctx, bindName, macro);
          pathId = pathMap.id(path);
          listener.getValue = function(model, triggerPath) {
            patchCtx(ctx, triggerPath);
            return dataValue(view, ctx, model, name, macro);
          };
        }
        return modelEvents.bind(pathId, listener);
      });
    })(bindName));
  }
  return _results;
};

bindEventsById = function(events, macro, name, partial, attrs, method, prop, isBlock) {
  return bindEvents(events, macro, name, partial, function(triggerId, blockPaths, pathId) {
    var id;
    id = attrs._id || attrs.id;
    if (isBlock && pathId) {
      blockPaths[id] = pathId;
    }
    return [id, method, prop];
  });
};

bindEventsByIdString = function(events, macro, name, partial, attrs, method, prop) {
  return bindEvents(events, macro, name, partial, function(triggerId) {
    var id;
    id = triggerId || attrs._id || attrs.id;
    return [id, method, prop];
  });
};

addId = function(view, attrs) {
  if (attrs.id == null) {
    return attrs.id = function() {
      return attrs._id = view._uniqueId();
    };
  }
};

reduceStack = function(stack) {
  var attrs, bool, html, i, item, key, pushValue, value, _i, _len;
  html = [''];
  i = 0;
  pushValue = function(value, isAttr) {
    if (value && value.call) {
      return i = html.push(value, '') - 1;
    } else {
      return html[i] += isAttr ? escapeAttr(value) : value;
    }
  };
  for (_i = 0, _len = stack.length; _i < _len; _i++) {
    item = stack[_i];
    switch (item[0]) {
      case 'start':
        html[i] += '<' + item[1];
        attrs = item[2];
        if ('id' in attrs) {
          html[i] += ' id=';
          pushValue(attrs.id, true);
        }
        for (key in attrs) {
          value = attrs[key];
          if (key === 'id') {
            continue;
          }
          if (value != null) {
            if (bool = value.bool) {
              pushValue(bool);
              continue;
            }
            html[i] += ' ' + key + '=';
            pushValue(value, true);
          } else {
            html[i] += ' ' + key;
          }
        }
        html[i] += '>';
        break;
      case 'chars':
        pushValue(item[1]);
        break;
      case 'end':
        html[i] += '</' + item[1] + '>';
        break;
      case 'marker':
        html[i] += '<!--' + item[1];
        pushValue(item[2].id);
        html[i] += '-->';
    }
  }
  return html;
};

patchCtx = function(ctx, triggerPath) {
  var i, index, indices, n, path, segment, segments, triggerSegment, triggerSegments, _i, _len;
  if (!(triggerPath && (path = ctx.$paths[0]))) {
    return;
  }
  segments = path.split('.');
  triggerSegments = triggerPath.replace(/\*$/, '').split('.');
  indices = ctx.$indices.slice();
  index = indices.length;
  for (i = _i = 0, _len = segments.length; _i < _len; i = ++_i) {
    segment = segments[i];
    triggerSegment = triggerSegments[i];
    if (segment === '$#' && (n = +triggerSegment) === n) {
      indices[--index] = n;
    } else if (segment !== triggerSegment) {
      break;
    }
  }
  return ctx.$indices = indices;
};

renderer = function(view, items, events, onRender) {
  return function(ctx, model, triggerPath, triggerId) {
    var blockPaths, dom, event, html, i, item, modelEvents, pathMap, _i, _len;
    patchCtx(ctx, triggerPath);
    model || (model = view.model);
    pathMap = model.__pathMap;
    modelEvents = model.__events;
    blockPaths = model.__blockPaths;
    dom = view.dom;
    html = '';
    if (onRender) {
      ctx = onRender(ctx);
    }
    for (_i = 0, _len = items.length; _i < _len; _i++) {
      item = items[_i];
      html += item.call ? item(ctx, model) || '' : item;
    }
    i = 0;
    while (event = events[i++]) {
      event(ctx, modelEvents, dom, pathMap, view, blockPaths, triggerId);
    }
    return html;
  };
};

extendCtx = function(ctx, value, name, alias, index, isArray) {
  var aliases, path;
  ctx = extend(ctx, value);
  ctx["this"] = value;
  if (alias) {
    aliases = ctx.$aliases = Object.create(ctx.$aliases);
    aliases[alias] = ctx.$depth;
  }
  if (path = ctxPath(ctx, name, null, true)) {
    ctx.$paths = [path].concat(ctx.$paths);
  }
  if (name) {
    ctx.$depth++;
  }
  if (index != null) {
    ctx.$indices = [index].concat(ctx.$indices);
    isArray = true;
  }
  if (isArray && ctx.$paths[0]) {
    ctx.$paths[0] += '.$#';
  }
  return ctx;
};

partialValue = function(view, ctx, model, name, value, listener, macro) {
  if (listener) {
    return value;
  }
  if (name) {
    return dataValue(view, ctx, model, name, macro);
  } else {
    return true;
  }
};

partialFn = function(view, name, type, alias, render, macroCtx, macro) {
  var conditionalRender, withFn;
  conditionalRender = function(ctx, model, triggerPath, value, index, condition) {
    var renderCtx;
    if (condition) {
      renderCtx = extendCtx(ctx, value, name, alias, index);
      return render(renderCtx, model, triggerPath);
    }
    return '';
  };
  withFn = function(ctx, model, triggerPath, triggerId, value, index, listener) {
    value = partialValue(view, ctx, model, name, value, listener, macro);
    return conditionalRender(ctx, model, triggerPath, value, index, true);
  };
  if (type === 'partial') {
    return function(ctx, model, triggerPath, triggerId, value, index, listener) {
      var parentMacroCtx, renderCtx;
      renderCtx = Object.create(ctx);
      renderCtx.$macroCtx = (parentMacroCtx = ctx.$macroCtx) ? extend(parentMacroCtx, macroCtx) : macroCtx;
      return render(renderCtx, model, triggerPath);
    };
  }
  if (type === 'with' || type === 'else') {
    return withFn;
  }
  if (type === 'if' || type === 'else if') {
    return function(ctx, model, triggerPath, triggerId, value, index, listener) {
      var condition;
      value = partialValue(view, ctx, model, name, value, listener, macro);
      condition = !!(Array.isArray(value) ? value.length : value);
      return conditionalRender(ctx, model, triggerPath, value, index, condition);
    };
  }
  if (type === 'unless') {
    return function(ctx, model, triggerPath, triggerId, value, index, listener) {
      var condition;
      value = partialValue(view, ctx, model, name, value, listener, macro);
      condition = !(Array.isArray(value) ? value.length : value);
      return conditionalRender(ctx, model, triggerPath, value, index, condition);
    };
  }
  if (type === 'each') {
    return function(ctx, model, triggerPath, triggerId, value, index, listener) {
      var i, indices, isArray, item, out, renderCtx, _i, _len;
      value = partialValue(view, ctx, model, name, value, listener, macro);
      isArray = Array.isArray(value);
      if (listener && !isArray) {
        return withFn(ctx, model, triggerPath, triggerId, value, index, true);
      }
      if (!isArray) {
        return '';
      }
      ctx = extendCtx(ctx, null, name, alias, null, true);
      out = '';
      indices = ctx.$indices;
      for (i = _i = 0, _len = value.length; _i < _len; i = ++_i) {
        item = value[i];
        renderCtx = extend(ctx, item);
        renderCtx["this"] = item;
        renderCtx.$indices = [i].concat(indices);
        out += render(renderCtx, model, triggerPath);
      }
      return out;
    };
  }
  throw new Error('Unknown block type: ' + type);
};

objectToString = Object.prototype.toString;

textFn = function(view, name, escape, macro) {
  return function(ctx, model) {
    var text, value;
    value = dataValue(view, ctx, model, name, macro);
    text = typeof value === 'string' ? value : value == null ? '' : value.toString === objectToString ? JSON.stringify(value) : value.toString();
    if (escape) {
      return escape(text);
    } else {
      return text;
    }
  };
};

sectionFn = function(view, queue) {
  var block, render;
  render = renderer(view, reduceStack(queue.stack), queue.events);
  block = queue.block;
  return partialFn(view, block.name, block.type, block.alias, render, null, block.macro);
};

blockFn = function(view, sections) {
  var fns, len, section;
  if (!(len = sections.length)) {
    return;
  }
  if (len === 1) {
    return sectionFn(view, sections[0]);
  } else {
    fns = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = sections.length; _i < _len; _i++) {
        section = sections[_i];
        _results.push(sectionFn(view, section));
      }
      return _results;
    })();
    return function(ctx, model, triggerPath, triggerId, value, index, listener) {
      var fn, out, _i, _len;
      for (_i = 0, _len = fns.length; _i < _len; _i++) {
        fn = fns[_i];
        out = fn(ctx, model, triggerPath, triggerId, value, index, listener);
        if (out) {
          return out;
        }
      }
      return '';
    };
  }
};

parseMarkup = function(type, attr, tagName, events, attrs, name) {
  var anyOut, anyParser, elOut, elParser, out, parser;
  if (!(parser = markup[type][attr])) {
    return;
  }
  if (anyParser = parser['*']) {
    anyOut = anyParser(events, attrs, name);
  }
  if (elParser = parser[tagName]) {
    elOut = elParser(events, attrs, name);
  }
  out = anyOut ? extend(anyOut, elOut) : elOut;
  if (out != null ? out.del : void 0) {
    delete attrs[attr];
  }
  return out;
};

pushChars = function(stack, text) {
  if (text) {
    return stack.push(['chars', text]);
  }
};

pushVarFn = function(view, stack, fn, name, escapeFn, macro) {
  if (fn) {
    return pushChars(stack, fn);
  } else {
    return pushChars(stack, textFn(view, name, escapeFn, macro));
  }
};

boundMacroName = function(boundMacro, name) {
  var macroVar;
  macroVar = name.split('.')[0];
  return boundMacro[macroVar];
};

isBound = function(boundMacro, match, name) {
  var arg, args, _i, _len;
  if (!(name && match.macro)) {
    return match.bound;
  }
  if (~name.indexOf('(')) {
    args = pathFnArgs(name);
    for (_i = 0, _len = args.length; _i < _len; _i++) {
      arg = args[_i];
      if (boundMacroName(boundMacro, arg)) {
        return true;
      }
    }
    return false;
  }
  return boundMacroName(boundMacro, name);
};

pushVar = function(view, ns, stack, events, boundMacro, remainder, match, fn) {
  var attr, attrs, escapeFn, last, macro, name, partial, tagName, wrap;
  name = match.name, partial = match.partial, macro = match.macro;
  escapeFn = match.escaped && escapeHtml;
  if (partial) {
    fn = partialFn(view, name, 'partial', match.alias, view._find(partial, ns, boundMacro), match.macroCtx);
  }
  if (isBound(boundMacro, match, name)) {
    last = stack[stack.length - 1];
    wrap = match.pre || !last || (last[0] !== 'start') || isVoid(tagName = last[1]) || wrapRemainder(tagName, remainder);
    if (wrap) {
      stack.push(['marker', '', attrs = {}]);
    } else {
      for (attr in attrs = last[2]) {
        parseMarkup('boundParent', attr, tagName, events, attrs, name);
      }
    }
    addId(view, attrs);
    bindEventsById(events, macro, name, fn, attrs, 'html', !fn && escapeFn, true);
  }
  pushVarFn(view, stack, fn, name, escapeFn, macro);
  if (wrap) {
    return stack.push([
      'marker', '$', {
        id: function() {
          return attrs._id;
        }
      }
    ]);
  }
};

pushVarString = function(view, ns, stack, events, boundMacro, remainder, match, fn) {
  var bindOnce, escapeFn, name;
  name = match.name;
  escapeFn = !match.escaped && unescapeEntities;
  bindOnce = function(ctx) {
    ctx.$onBind(events, name);
    return bindOnce = empty;
  };
  if (isBound(boundMacro, match, name)) {
    events.push(function(ctx) {
      return bindOnce(ctx);
    });
  }
  return pushVarFn(view, stack, fn, name, escapeFn, match.macro);
};

parseMatchError = function(text, message) {
  throw new Error(message + '\n\n' + text + '\n');
};

onBlock = function(start, end, block, queues, callbacks) {
  var boundMacro, lastQueue, queue;
  if (end) {
    lastQueue = queues.pop();
    queue = queues.last();
    queue.sections.push(lastQueue);
  } else {
    queue = queues.last();
  }
  if (start) {
    boundMacro = Object.create(queue.boundMacro);
    queues.push(queue = {
      stack: [],
      events: [],
      block: block,
      sections: [],
      boundMacro: boundMacro
    });
    callbacks.onStart(queue);
  } else {
    if (end) {
      callbacks.onStart(queue);
      callbacks.onEnd(queue.sections);
      queue.sections = [];
    } else {
      callbacks.onContent(block);
    }
  }
};

parseMatch = function(text, match, queues, callbacks) {
  var block, blockType, endBlock, hash, name, startBlock, type;
  hash = match.hash, type = match.type, name = match.name;
  block = queues.last().block;
  blockType = block && block.type;
  if (type === 'if' || type === 'unless' || type === 'each' || type === 'with') {
    if (hash === '#') {
      startBlock = true;
    } else if (hash === '/') {
      endBlock = true;
    } else {
      parseMatchError(text, type + ' blocks must begin with a #');
    }
  } else if (type === 'else' || type === 'else if') {
    if (hash) {
      parseMatchError(text, type + ' blocks may not start with ' + hash);
    }
    if (blockType !== 'if' && blockType !== 'else if' && blockType !== 'unless' && blockType !== 'each') {
      parseMatchError(text, type + ' may only follow `if`, `else if`, `unless`, or `each`');
    }
    startBlock = true;
    endBlock = true;
  } else if (hash === '/') {
    endBlock = true;
  } else if (hash === '#') {
    parseMatchError(text, '# must be followed by `if`, `unless`, `each`, or `with`');
  }
  if (endBlock && !block) {
    parseMatchError(text, 'Unmatched template end tag');
  }
  return onBlock(startBlock, endBlock, match, queues, callbacks);
};

parseAttr = function(view, viewName, events, boundMacro, tagName, attrs, attr, value) {
  var macro, match, name, out, render;
  if (typeof value === 'function') {
    return;
  }
  if (match = extractPlaceholder(value)) {
    name = match.name, macro = match.macro;
    if (match.pre || match.post) {
      addId(view, attrs);
      render = parse(view, viewName, value, true, function(events, name) {
        return bindEventsByIdString(events, macro, name, render, attrs, 'attr', attr);
      }, boundMacro);
      attrs[attr] = attr === 'id' ? function(ctx, model) {
        return attrs._id = escapeAttr(render(ctx, model));
      } : function(ctx, model) {
        return escapeAttr(render(ctx, model));
      };
      return;
    }
    out = parseMarkup('bound', attr, tagName, events, attrs, name) || {};
    if (isBound(boundMacro, match, name)) {
      addId(view, attrs);
      bindEventsById(events, macro, name, null, attrs, out.method || 'attr', out.property || attr);
    }
    if (!out.del) {
      macro = match.macro;
      attrs[attr] = out.bool ? {
        bool: function(ctx, model) {
          if (dataValue(view, ctx, model, name, macro)) {
            return ' ' + attr;
          } else {
            return '';
          }
        }
      } : textFn(view, name, escapeAttr, macro);
    }
  }
  out = parseMarkup('attr', attr, tagName, events, attrs, value);
  if (out != null ? out.addId : void 0) {
    addId(view, attrs);
  }
};

parsePartialAttr = function(view, viewName, events, attrs, attr, value) {
  var bound, match, name;
  if (attr === 'content') {
    throw new Error('components may not have an attribute named "content"');
  }
  bound = false;
  if (match = extractPlaceholder(value)) {
    name = match.name, bound = match.bound;
    if (match.pre || match.post) {
      throw new Error('unimplemented: blocks in component attributes');
    }
    attrs[attr] = {
      $macroVar: name
    };
  } else if (value === 'true') {
    attrs[attr] = true;
  } else if (value === 'false') {
    attrs[attr] = false;
  } else if (value === 'null') {
    attrs[attr] = null;
  } else if (!isNaN(value)) {
    attrs[attr] = +value;
  }
  return bound;
};

partialName = function(view, tagName) {
  var i, partial, tagNs;
  if (!~(i = tagName.indexOf(':'))) {
    return;
  }
  tagNs = tagName.slice(0, i);
  if (!view._componentNamespaces[tagNs]) {
    return;
  }
  return partial = tagName.slice(i + 1);
};

parse = function(view, viewName, template, isString, onBind, boundMacro) {
  var chars, end, events, index, ns, onRender, onStart, push, queues, stack, start;
  if (boundMacro == null) {
    boundMacro = {};
  }
  queues = [
    {
      stack: stack = [],
      events: events = [],
      sections: [],
      boundMacro: boundMacro
    }
  ];
  queues.last = function() {
    return queues[queues.length - 1];
  };
  onStart = function(queue) {
    return stack = queue.stack, events = queue.events, boundMacro = queue.boundMacro, queue;
  };
  if (isString) {
    push = pushVarString;
    onRender = function(ctx) {
      if (ctx.$stringCtx) {
        return ctx;
      }
      ctx = Object.create(ctx);
      ctx.$onBind = onBind;
      ctx.$stringCtx = ctx;
      return ctx;
    };
  } else {
    push = pushVar;
  }
  ns = ~(index = viewName.lastIndexOf(':')) ? viewName.slice(0, index) : '';
  start = function(tag, tagName, attrs) {
    var attr, block, bound, isNonvoid, out, parser, partial, value;
    if (partial = partialName(view, tagName)) {
      isNonvoid = view._findItem(partial, ns, '_nonvoidComponents');
      for (attr in attrs) {
        value = attrs[attr];
        bound = parsePartialAttr(view, viewName, events, attrs, attr, value);
        if (bound) {
          boundMacro[attr] = true;
        }
      }
      block = {
        partial: partial,
        macroCtx: attrs
      };
      if (isNonvoid) {
        onBlock(true, false, block, queues, {
          onStart: onStart
        });
      } else {
        push(view, ns, stack, events, boundMacro, '', block);
      }
      return;
    }
    if (parser = markup.element[tagName]) {
      out = parser(events, attrs);
      if (out != null ? out.addId : void 0) {
        addId(view, attrs);
      }
    }
    for (attr in attrs) {
      value = attrs[attr];
      parseAttr(view, viewName, events, boundMacro, tagName, attrs, attr, value);
    }
    return stack.push(['start', tagName, attrs]);
  };
  chars = function(text, isRawText, remainder) {
    var match, post, pre;
    if (isRawText || !(match = extractPlaceholder(text))) {
      text = isString ? unescapeEntities(trim(text)) : trim(text);
      pushChars(stack, text);
      return;
    }
    pre = match.pre, post = match.post;
    if (isString) {
      pre = unescapeEntities(pre);
    }
    pushChars(stack, pre);
    remainder = post || remainder;
    parseMatch(text, match, queues, {
      onStart: onStart,
      onEnd: function(sections) {
        var fn;
        fn = blockFn(view, sections);
        return push(view, ns, stack, events, boundMacro, remainder, sections[0].block, fn);
      },
      onContent: function(match) {
        return push(view, ns, stack, events, boundMacro, remainder, match);
      }
    });
    if (post) {
      return chars(post);
    }
  };
  end = function(tag, tagName) {
    var partial;
    if (partial = partialName(view, tagName)) {
      onBlock(false, true, null, queues, {
        onStart: onStart,
        onEnd: function(_arg) {
          var block, queue;
          queue = _arg[0];
          block = queue.block;
          block.macroCtx.content = renderer(view, reduceStack(queue.stack), queue.events);
          return push(view, ns, stack, events, boundMacro, '', block);
        }
      });
      return;
    }
    return stack.push(['end', tagName]);
  };
  if (isString) {
    chars(template);
  } else {
    parseHtml(template, {
      start: start,
      chars: chars,
      end: end
    });
  }
  return renderer(view, reduceStack(stack), events, onRender);
};
