// Generated by CoffeeScript 1.3.1
var Dom, EventDispatcher, addListener, doc, elements, escapeHtml, fns, forChildren, getMethods, getNaN, getProp, getRange, lookup, markers, merge, removeListener, setMethods, win;

merge = require('racer/lib/util').merge;

lookup = require('racer/lib/path').lookup;

EventDispatcher = require('./EventDispatcher');

escapeHtml = require('./html').escapeHtml;

markers = {};

elements = {
  $_win: win = window,
  $_doc: doc = win.document
};

Dom = module.exports = function(model, appExports) {
  var captureEvents, captureListenerAdded, captureTrigger, dom, events, listenerAdded, onTrigger, trigger;
  dom = this;
  listenerAdded = {};
  captureListenerAdded = {};
  onTrigger = function(name, listener, id, e, el, next) {
    var delay, finish, fn;
    if ((fn = listener.fn) != null) {
      finish = fns[fn] || appExports[fn] || lookup(fn, appExports);
      if (!finish) {
        return;
      }
    } else {
      finish = function() {
        var path, setValue, value;
        value = getMethods[listener.method](el, listener.property);
        if (setValue = listener.setValue) {
          setValue(model, value);
          return;
        }
        if (!(path = model.__pathMap.paths[listener.pathId])) {
          return false;
        }
        if (model.get(path) === value) {
          return;
        }
        return model.pass(e).set(path, value);
      };
    }
    if ((delay = listener.delay) != null) {
      setTimeout(finish, delay, e, el, next, dom);
    } else {
      finish(e, el, next, dom);
    }
  };
  this._events = events = new EventDispatcher({
    onTrigger: onTrigger,
    onBind: function(name, listener, eventName) {
      if (!listenerAdded[eventName]) {
        addListener(doc, eventName, trigger, true);
        listenerAdded[eventName] = true;
      }
    }
  });
  this._captureEvents = captureEvents = new EventDispatcher({
    onTrigger: function(name, listener, e) {
      var el, id;
      id = listener.id;
      el = doc.getElementById(id);
      if (el.tagName === 'HTML' || el.contains(e.target)) {
        onTrigger(name, listener, id, e, el);
      }
    },
    onBind: function(name, listener) {
      if (!captureListenerAdded[name]) {
        addListener(doc, name, captureTrigger, true);
        captureListenerAdded[name] = true;
      }
    }
  });
  this.trigger = trigger = function(e, el, noBubble, continued) {
    var id, next, prefix;
    prefix = e.type + ':';
    el || (el = e.target);
    next = function() {
      return trigger(e, el.parentNode, false, true);
    };
    next.firstTrigger = !continued;
    if (noBubble && (id = el.id)) {
      return events.trigger(prefix + id, id, e, el, next);
    }
    while (true) {
      while (!(id = el.id)) {
        if (!(el = el.parentNode)) {
          return;
        }
      }
      if (events.trigger(prefix + id, id, e, el, next)) {
        return;
      }
      el = el.parentNode;
    }
  };
  this.captureTrigger = captureTrigger = function(e) {
    return captureEvents.trigger(e.type, e);
  };
  this.addListener = addListener;
  this.removeListener = removeListener;
};

Dom.prototype = {
  clear: function() {
    this._events.clear();
    this._captureEvents.clear();
    return markers = {};
  },
  bind: function(eventName, id, listener) {
    if (listener.capture) {
      listener.id = id;
      return this._captureEvents.bind(eventName, listener);
    } else {
      return this._events.bind("" + eventName + ":" + id, listener, eventName);
    }
  },
  update: function(el, method, ignore, value, property, index) {
    if (value === getMethods[method](el, property)) {
      return;
    }
    return setMethods[method](el, ignore, value, property, index);
  },
  item: function(id) {
    return doc.getElementById(id) || elements[id] || getRange(id);
  },
  getMethods: getMethods = {
    attr: function(el, attr) {
      return el.getAttribute(attr);
    },
    prop: getProp = function(el, prop) {
      return el[prop];
    },
    propPolite: getProp,
    html: function(el) {
      return el.innerHTML;
    },
    append: getNaN = function() {
      return NaN;
    },
    insert: getNaN,
    remove: getNaN,
    move: getNaN
  },
  setMethods: setMethods = {
    attr: function(el, ignore, value, attr) {
      if (ignore && el.id === ignore) {
        return;
      }
      el.setAttribute(attr, value);
    },
    prop: function(el, ignore, value, prop) {
      if (ignore && el.id === ignore) {
        return;
      }
      el[prop] = value;
    },
    propPolite: function(el, ignore, value, prop) {
      if (ignore && el.id === ignore) {
        return;
      }
      if (el !== doc.activeElement || !doc.hasFocus()) {
        el[prop] = value;
      }
    },
    html: function(obj, ignore, value, escape) {
      if (escape) {
        value = escapeHtml(value);
      }
      if (obj.nodeType) {
        if (ignore && obj.id === ignore) {
          return;
        }
        obj.innerHTML = value;
      } else {
        obj.deleteContents();
        obj.insertNode(obj.createContextualFragment(value));
      }
    },
    append: function(obj, ignore, value, escape) {
      var el, ref;
      if (escape) {
        value = escapeHtml(value);
      }
      if (obj.nodeType) {
        obj.insertAdjacentHTML('beforeend', value);
      } else {
        el = obj.endContainer;
        obj.endOffset;
        ref = el.childNodes[obj.endOffset];
        el.insertBefore(obj.createContextualFragment(value), ref);
      }
    },
    insert: function(obj, ignore, value, escape, index) {
      var el, ref;
      if (escape) {
        value = escapeHtml(value);
      }
      if (obj.nodeType) {
        if (ref = obj.childNodes[index]) {
          ref.insertAdjacentHTML('beforebegin', value);
        } else {
          obj.insertAdjacentHTML('beforeend', value);
        }
      } else {
        el = obj.startContainer;
        ref = el.childNodes[obj.startOffset + index];
        el.insertBefore(obj.createContextualFragment(value), ref);
      }
    },
    remove: function(el, ignore, index) {
      var child;
      if (!el.nodeType) {
        index += el.startOffset;
        el = el.startContainer;
      }
      child = el.childNodes[index];
      if (child) {
        el.removeChild(child);
      }
    },
    move: function(el, ignore, from, to, howMany) {
      var child, fragment, nextChild, offset, ref, toEl;
      if (!el.nodeType) {
        offset = el.startOffset;
        from += offset;
        to += offset;
        el = el.startContainer;
      }
      child = el.childNodes[from];
      if (!child || ignore && (toEl = el.childNodes[to]) && toEl.id === ignore || child.id === ignore) {
        return;
      }
      ref = el.childNodes[to > from ? to + howMany : to];
      if (howMany > 1) {
        fragment = document.createDocumentFragment();
        while (howMany--) {
          nextChild = child.nextSibling;
          fragment.appendChild(child);
          if (!(child = nextChild)) {
            break;
          }
        }
        el.insertBefore(fragment, ref);
        return;
      }
      el.insertBefore(child, ref);
    }
  },
  fns: fns = {
    $forChildren: forChildren = function(e, el, next, dom) {
      var child, _i, _len, _ref;
      if (!next.firstTrigger) {
        return;
      }
      _ref = el.childNodes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        child = _ref[_i];
        if (child.nodeType !== 1) {
          continue;
        }
        dom.trigger(e, child, true, true);
        forChildren(e, child, next, dom);
      }
    },
    $forName: function(e, el, next, dom) {
      var element, name, _i, _len;
      if (!next.firstTrigger) {
        return;
      }
      if (!(name = el.getAttribute('name'))) {
        return;
      }
      elements = doc.getElementsByName(name);
      if (!(elements.length > 1)) {
        return;
      }
      for (_i = 0, _len = elements.length; _i < _len; _i++) {
        element = elements[_i];
        if (element === el) {
          continue;
        }
        dom.trigger(e, element, false, true);
      }
    }
  }
};

getRange = function(name) {
  var comment, commentIterator, end, range, start;
  start = markers[name];
  end = markers['$' + name];
  if (!(start && end)) {
    commentIterator = doc.createTreeWalker(doc.body, 128, null, false);
    while (comment = commentIterator.nextNode()) {
      markers[comment.data] = comment;
    }
    start = markers[name];
    end = markers['$' + name];
    if (!(start && end)) {
      return;
    }
  }
  if (!doc.body.contains(start)) {
    delete markers[name];
    delete markers['$' + name];
    return;
  }
  range = doc.createRange();
  range.setStartAfter(start);
  range.setEndBefore(end);
  return range;
};

if (doc.addEventListener) {
  addListener = function(el, name, cb, captures) {
    if (captures == null) {
      captures = false;
    }
    return el.addEventListener(name, cb, captures);
  };
  removeListener = function(el, name, cb, captures) {
    if (captures == null) {
      captures = false;
    }
    return el.removeEventListener(name, cb, captures);
  };
} else if (doc.attachEvent) {
  addListener = function(el, name, cb) {
    return el.attachEvent('on' + name, function() {
      event.target || (event.target = event.srcElement);
      return cb(event);
    });
  };
  removeListener = function() {
    throw new Error('Not implemented');
  };
}

if (!doc.body.contains) {
  Node.prototype.contains = function(node) {
    return !!(this.compareDocumentPosition(node) & 16);
  };
}

if (!doc.body.insertAdjacentHTML) {
  HTMLElement.prototype.insertAdjacentHTML = function(position, html) {
    var container, firstChild, nextSibling, node, parent, ref;
    ref = this;
    parent = ref.parentNode;
    container = doc.createElement(parent.tagName);
    container.innerHTML = html;
    switch (position.toLowerCase()) {
      case 'beforeend':
        while (node = container.firstChild) {
          ref.appendChild(node);
        }
        break;
      case 'beforebegin':
        while (node = container.firstChild) {
          parent.insertBefore(node, ref);
        }
        break;
      case 'afterend':
        nextSibling = ref.nextSibling;
        while (node = container.lastChild) {
          nextSibling = parent.insertBefore(node, nextSibling);
        }
        break;
      case 'afterbegin':
        firstChild = ref.firstChild;
        while (node = container.lastChild) {
          firstChild = ref.insertBefore(node, firstChild);
        }
    }
  };
}
