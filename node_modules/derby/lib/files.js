// Generated by CoffeeScript 1.3.1
var Promise, basename, compactHtml, crypto, dirname, exists, extensions, files, findPath, finishAfter, fs, hashFile, ignoreDirectories, ignored, join, loadTemplates, nib, onlyWhitespace, parseHtml, parseTemplateFile, racer, relative, stylus, trim, _ref;

_ref = require('path'), dirname = _ref.dirname, basename = _ref.basename, join = _ref.join, exists = _ref.exists, relative = _ref.relative;

fs = require('fs');

crypto = require('crypto');

stylus = require('stylus');

nib = require('nib');

racer = require('racer');

Promise = require('racer/lib/Promise');

finishAfter = require('racer/lib/util/async').finishAfter;

parseHtml = require('./html').parse;

trim = require('./View').trim;

module.exports = {
  css: function(root, clientName, compress, callback) {
    return findPath(root + '/styles', clientName, '.styl', function(path) {
      if (!path) {
        return callback('');
      }
      return fs.readFile(path, 'utf8', function(err, styl) {
        if (err) {
          return callback(err);
        }
        return stylus(styl).use(nib()).set('filename', path).set('compress', compress).render(callback);
      });
    });
  },
  templates: function(root, clientName, callback) {
    var calls, count;
    count = 0;
    calls = {
      incr: function() {
        return count++;
      },
      finish: function(err, templates, instances) {
        if (err) {
          calls.finish = function() {};
          return callback(err);
        }
        return --count || callback(null, templates, instances);
      }
    };
    return loadTemplates(root + '/views', clientName, 'import', calls);
  },
  js: function(parentFilename, callback) {
    var finish, inline, inlineFile, js;
    inlineFile = join(dirname(parentFilename), 'inline.js');
    js = inline = null;
    finish = finishAfter(2, function(err) {
      return callback(err, js, inline);
    });
    racer.js({
      require: parentFilename
    }, function(err, value) {
      js = value;
      return finish(err);
    });
    return fs.readFile(inlineFile, 'utf8', function(err, value) {
      inline = value;
      if (err && err.code === 'ENOENT') {
        err = null;
      }
      return finish(err);
    });
  },
  parseName: function(parentFilename, options) {
    var base, parentDir, root;
    root = parentDir = dirname(parentFilename);
    if ((base = basename(parentFilename, '.js')) === 'index') {
      base = basename(parentDir);
      root = dirname(dirname(parentDir));
    } else if (basename(parentDir) === 'lib') {
      root = dirname(parentDir);
    }
    return {
      root: root,
      clientName: options.name || base,
      require: './' + basename(parentFilename)
    };
  },
  hashFile: hashFile = function(s) {
    var hash;
    hash = crypto.createHash('md5').update(s).digest('base64');
    return hash.replace(/[\/\+=]/g, function(match) {
      switch (match) {
        case '/':
          return '-';
        case '+':
          return '_';
        case '=':
          return '';
      }
    });
  },
  writeJs: function(root, js, options, callback) {
    var filePath, filename, finish, hash, jsFile, staticDir, staticPath, staticRoot;
    staticRoot = options.staticRoot || join(root, 'public');
    staticDir = options.staticDir || 'gen';
    staticPath = join(staticRoot, staticDir);
    hash = hashFile(js);
    filename = hash + '.js';
    jsFile = join('/', staticDir, filename);
    filePath = join(staticPath, filename);
    finish = function() {
      return fs.writeFile(filePath, js, function(err) {
        return callback(err, jsFile, hash);
      });
    };
    return exists(staticPath, function(value) {
      if (value) {
        return finish();
      }
      return exists(staticRoot, function(value) {
        if (value) {
          return fs.mkdir(staticPath, '0777', function(err) {
            return finish();
          });
        }
        return fs.mkdir(staticRoot, '0777', function(err) {
          return fs.mkdir(staticPath, '0777', function(err) {
            return finish();
          });
        });
      });
    });
  },
  watch: function(dir, type, onChange) {
    var extension, options;
    options = {
      interval: 100
    };
    extension = extensions[type];
    return files(dir, extension).forEach(function(file) {
      return fs.watchFile(file, options, function(curr, prev) {
        if (prev.mtime < curr.mtime) {
          return onChange(file);
        }
      });
    });
  }
};

onlyWhitespace = /^[\s\n]*$/;

findPath = function(root, name, extension, callback) {
  var path;
  if (name.charAt(0) !== '/') {
    name = join(root, name);
  }
  path = name + extension;
  return exists(path, function(value) {
    if (value) {
      return callback(path);
    }
    path = join(name, 'index' + extension);
    return exists(path, function(value) {
      return callback(value ? path : null);
    });
  });
};

loadTemplates = function(root, fileName, get, calls, files, templates, instances, alias, currentNs) {
  if (currentNs == null) {
    currentNs = '';
  }
  calls.incr();
  return findPath(root, fileName, '.html', function(path) {
    var getCount, got, matchesGet, promise;
    if (path === null) {
      if (!files) {
        return calls.finish(null, {}, {});
      } else {
        return calls.finish(new Error("Can't find file " + fileName));
      }
    }
    files || (files = {});
    templates || (templates = {});
    instances || (instances = {});
    got = false;
    if (get === 'import') {
      matchesGet = function() {
        got = true;
        return true;
      };
    } else if (Array.isArray(get)) {
      getCount = get.length;
      matchesGet = function(name) {
        --getCount || (got = true);
        return ~get.indexOf(name);
      };
    } else {
      matchesGet = function(name) {
        got = true;
        return get === name;
      };
    }
    if (!(promise = files[path])) {
      promise = files[path] = new Promise;
      fs.readFile(path, 'utf8', function(err, file) {
        return promise.resolve(err, file);
      });
    }
    return promise.on(function(err, file) {
      if (err) {
        calls.finish(err);
      }
      parseTemplateFile(root, dirname(path), path, calls, files, templates, instances, alias, currentNs, matchesGet, file);
      if (!got) {
        calls.finish(new Error("Can't find template '" + get + "' in " + path));
      }
      return calls.finish(null, templates, instances);
    });
  });
};

compactHtml = function(html) {
  var compact, onTag, onText;
  compact = '';
  onTag = function(tag) {
    return compact += tag.replace(/\n\s*/g, '\n');
  };
  onText = function(text) {
    return compact += trim(text);
  };
  parseHtml(html, {
    start: onTag,
    end: onTag,
    chars: onText
  });
  return compact;
};

parseTemplateFile = function(root, dir, path, calls, files, templates, instances, alias, currentNs, matchesGet, file) {
  var as, importTemplates, name, ns, relativePath, src, templateOptions;
  name = src = ns = as = importTemplates = templateOptions = null;
  relativePath = relative(root, path);
  return parseHtml(file, {
    start: function(tag, tagName, attrs) {
      var i, srcNs, template;
      name = src = ns = as = importTemplates = null;
      i = tagName.length - 1;
      name = (tagName.charAt(i) === ':' ? tagName.slice(0, i) : '').toLowerCase();
      if (name === 'import') {
        src = attrs.src, ns = attrs.ns, as = attrs.as, template = attrs.template;
        if (!src) {
          calls.finish(new Error("Template import in " + path + " must have a 'src' attribute"));
        }
        if (template) {
          importTemplates = template.toLowerCase().split(' ');
          if (importTemplates.length > 1 && (as != null)) {
            calls.finish(new Error("Template import of '" + src + "' in " + path + " can't specify multiple 'template' values with 'as'"));
          }
        }
        ns = 'ns' in attrs ? (as ? calls.finish(new Error("Template import of '" + src + "' in " + path + " can't specifiy both 'ns' and 'as' attributes")) : void 0, ns ? currentNs ? currentNs + ':' + ns : ns : currentNs) : as ? currentNs : (srcNs = src.replace(/^[.\/]*/, ''), currentNs ? currentNs + ':' + srcNs : srcNs);
        ns = ns.toLowerCase();
      } else {
        templateOptions = attrs;
      }
    },
    chars: function(text, literal) {
      var instanceName, templateName, toGet;
      if (!matchesGet(name)) {
        return;
      }
      if (src) {
        if (!onlyWhitespace.test(text)) {
          calls.finish(new Error("Template import of '" + src + "' in " + path + " can't contain content"));
        }
        toGet = importTemplates || 'import';
        return loadTemplates(root, join(dir, src), toGet, calls, files, templates, instances, as, ns);
      }
      templateName = relativePath + ':' + name;
      instanceName = alias || name;
      if (currentNs) {
        instanceName = currentNs + ':' + instanceName;
      }
      instances[instanceName] = [templateName, templateOptions];
      if (templates[templateName]) {
        return;
      }
      if (!(name && literal)) {
        if (onlyWhitespace.test(text)) {
          return;
        }
        calls.finish(new Error("Can't read template in " + path + " near the text: " + text));
      }
      return templates[templateName] = compactHtml(text);
    }
  });
};

extensions = {
  html: /\.html$/,
  css: /\.styl$|\.css$/,
  js: /\.js$/
};

ignoreDirectories = ['node_modules', '.git', 'gen'];

ignored = function(path) {
  return ignoreDirectories.indexOf(path) === -1;
};

files = function(dir, extension, out) {
  if (out == null) {
    out = [];
  }
  fs.readdirSync(dir).filter(ignored).forEach(function(p) {
    p = join(dir, p);
    if (fs.statSync(p).isDirectory()) {
      return files(p, extension, out);
    } else if (extension.test(p)) {
      return out.push(p);
    }
  });
  return out;
};
