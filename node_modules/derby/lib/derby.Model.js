// Generated by CoffeeScript 1.3.1
var EventDispatcher, Model, PathMap, insert, refIndex, remove, triggerEach,
  __slice = [].slice;

EventDispatcher = require('./EventDispatcher');

PathMap = require('./PathMap');

Model = require('racer').Model;

Model.prototype.__at = Model.prototype.at;

Model.prototype.at = function(node, absolute) {
  var blockPaths, child, comment, commentIterator, i, id, isArray, last, path, pathId, pathMap, _i, _len, _ref;
  if (!(node && (node.parentNode || node.jquery && (node = node[0])))) {
    return this.__at(node, absolute);
  }
  commentIterator = document.createTreeWalker(document.body, 128, null, false);
  while (comment = commentIterator.nextNode()) {
    if (comment.$derbyChecked) {
      continue;
    }
    comment.$derbyChecked = true;
    id = comment.data;
    if (id.charAt(0) !== '$') {
      continue;
    }
    if (id.charAt(1) === '$') {
      comment.$derbyMarkerEnd = true;
      id = id.slice(1);
    }
    comment.$derbyMarkerId = id;
    comment.parentNode.$derbyMarkerParent = true;
  }
  blockPaths = this.__blockPaths;
  pathMap = this.__pathMap;
  while (node) {
    if (node.$derbyMarkerParent) {
      node = last;
      while (node = node.previousSibling) {
        if (!(id = node.$derbyMarkerId)) {
          continue;
        }
        if (node.$derbyMarkerEnd) {
          break;
        }
        if (!(pathId = blockPaths[id])) {
          break;
        }
        path = pathMap.paths[pathId];
        if (pathMap.arrays[path] && last) {
          i = 0;
          while (node = node.nextSibling) {
            if (node === last) {
              path = path + '.' + i;
              break;
            }
            i++;
          }
        }
        return this.__at(path, absolute);
      }
      last = last.parentNode;
      node = last.parentNode;
      continue;
    }
    if ((id = node.id) && (pathId = blockPaths[id])) {
      path = pathMap.paths[pathId];
      isArray = pathMap.arrays[path] || Array.isArray(this.get(path));
      if (isArray && last) {
        _ref = node.childNodes;
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          child = _ref[i];
          if (child === last) {
            path = path + '.' + i;
            break;
          }
        }
      }
      return this.__at(path, absolute);
    }
    last = node;
    node = node.parentNode;
  }
  return this;
};

exports.init = function(model, dom, view) {
  var event, events, pathMap, _fn, _i, _len, _ref;
  pathMap = model.__pathMap = new PathMap;
  events = model.__events = new EventDispatcher({
    onTrigger: function(pathId, listener, type, local, options, value, index, arg) {
      var el, id, method, partial, path, property, triggerId;
      id = listener[0];
      if (!(el = dom.item(id))) {
        return false;
      }
      method = listener[1];
      property = listener[2];
      partial = listener.partial;
      path = pathMap.paths[pathId];
      if (method === 'propPolite' && local) {
        method = 'prop';
      }
      if (partial) {
        triggerId = id;
        if (method === 'html' && type) {
          method = type;
          if (type === 'append') {
            path += '.' + (index = model.get(path).length - 1);
            triggerId = null;
          } else if (type === 'insert') {
            path += '.' + index;
            triggerId = null;
          } else if (type === 'remove') {
            partial = null;
          } else if (type === 'move') {
            partial = null;
            property = arg;
          }
        }
      }
      if (listener.getValue) {
        value = listener.getValue(model, path);
      }
      if (partial) {
        value = partial(listener.ctx, model, path, triggerId, value, index, listener);
        if (value == null) {
          return;
        }
      }
      dom.update(el, method, options && options.ignore, value, property, index);
    }
  });
  model.listeners('set').unshift(function(args, out, local, pass) {
    var arrayPath, i, index, path, value;
    model.emit('pre:set', args, out, local, pass);
    path = args[0], value = args[1];
    if (/\.\d+$/.test(path)) {
      i = path.lastIndexOf('.');
      arrayPath = path.slice(0, i);
      index = path.slice(i + 1);
      triggerEach(events, pathMap, arrayPath, 'remove', local, pass, index);
      triggerEach(events, pathMap, arrayPath, 'insert', local, pass, value, index);
    }
    return triggerEach(events, pathMap, path, 'html', local, pass, value);
  });
  model.listeners('del').unshift(function(args, out, local, pass) {
    var path;
    model.emit('pre:del', args, out, local, pass);
    path = args[0];
    return triggerEach(events, pathMap, path, 'html', local, pass);
  });
  model.listeners('push').unshift(function(args, out, local, pass) {
    var path, value, values, _i, _len;
    model.emit('pre:push', args, out, local, pass);
    path = args[0], values = 2 <= args.length ? __slice.call(args, 1) : [];
    for (_i = 0, _len = values.length; _i < _len; _i++) {
      value = values[_i];
      triggerEach(events, pathMap, path, 'append', local, pass, value);
    }
  });
  model.listeners('move').unshift(function(args, out, local, pass) {
    var from, howMany, len, path, to;
    model.emit('pre:move', args, out, local, pass);
    path = args[0], from = args[1], to = args[2], howMany = args[3];
    len = model.get(path).length;
    from = refIndex(from);
    to = refIndex(to);
    if (from < 0) {
      from += len;
    }
    if (to < 0) {
      to += len;
    }
    if (from === to) {
      return;
    }
    pathMap.onMove(path, from, to, howMany);
    return triggerEach(events, pathMap, path, 'move', local, pass, from, howMany, to);
  });
  model.listeners('unshift').unshift(function(args, out, local, pass) {
    var path, values;
    model.emit('pre:unshift', args, out, local, pass);
    path = args[0], values = 2 <= args.length ? __slice.call(args, 1) : [];
    return insert(events, pathMap, path, 0, values, local, pass);
  });
  model.listeners('insert').unshift(function(args, out, local, pass) {
    var index, path, values;
    model.emit('pre:insert', args, out, local, pass);
    path = args[0], index = args[1], values = 3 <= args.length ? __slice.call(args, 2) : [];
    return insert(events, pathMap, path, index, values, local, pass);
  });
  model.listeners('remove').unshift(function(args, out, local, pass) {
    var howMany, path, start;
    model.emit('pre:remove', args, out, local, pass);
    path = args[0], start = args[1], howMany = args[2];
    return remove(events, pathMap, path, start, howMany, local, pass);
  });
  model.listeners('pop').unshift(function(args, out, local, pass) {
    var path;
    model.emit('pre:pop', args, out, local, pass);
    path = args[0];
    return remove(events, pathMap, path, model.get(path).length, 1, local, pass);
  });
  model.listeners('shift').unshift(function(args, out, local, pass) {
    var path;
    model.emit('pre:shift', args, out, local, pass);
    path = args[0];
    return remove(events, pathMap, path, 0, 1, local, pass);
  });
  _ref = ['connected', 'canConnect'];
  _fn = function(event) {
    return model.listeners(event).unshift(function(value) {
      return triggerEach(events, pathMap, event, null, true, null, value);
    });
  };
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    event = _ref[_i];
    _fn(event);
  }
  model.on('reInit', function() {
    return view.history.refresh();
  });
  return model;
};

triggerEach = function(events, pathMap, path, arg0, arg1, arg2, arg3, arg4, arg5) {
  var i, id, pattern, segments;
  if (id = pathMap.ids[path]) {
    events.trigger(id, arg0, arg1, arg2, arg3, arg4, arg5);
  }
  segments = path.split('.');
  i = segments.length + 1;
  while (--i) {
    pattern = segments.slice(0, i).join('.') + '*';
    if (id = pathMap.ids[pattern]) {
      events.trigger(id, arg0, arg1, arg2, arg3, arg4, arg5);
    }
  }
};

refIndex = function(obj) {
  if (typeof obj === 'object') {
    return obj.index;
  } else {
    return +obj;
  }
};

insert = function(events, pathMap, path, start, values, local, pass) {
  var i, value, _i, _len;
  start = refIndex(start);
  pathMap.onInsert(path, start, values.length);
  for (i = _i = 0, _len = values.length; _i < _len; i = ++_i) {
    value = values[i];
    triggerEach(events, pathMap, path, 'insert', local, pass, value, start + i);
  }
};

remove = function(events, pathMap, path, start, howMany, local, pass) {
  var end, index, _i;
  start = refIndex(start);
  end = start + howMany;
  pathMap.onRemove(path, start, howMany);
  for (index = _i = start; start <= end ? _i < end : _i > end; index = start <= end ? ++_i : --_i) {
    triggerEach(events, pathMap, path, 'remove', local, pass, index);
  }
};
