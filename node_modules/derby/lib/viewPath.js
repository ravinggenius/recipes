// Generated by CoffeeScript 1.3.1
var argSeparator, ctxPath, dataValue, extractPlaceholder, fnArgValue, fnArgs, fnCall, fnCallError, fnValue, lookup, matchBraces, notPathArg, notSeparator, openPlaceholder, pathFnArgs, placeholderContent, setBoundFn, trim, _ctxPath;

lookup = require('racer/lib/path').lookup;

exports.trim = trim = function(s) {
  if (s) {
    return s.replace(/\n\s*/g, '');
  } else {
    return '';
  }
};

exports.wrapRemainder = function(tagName, remainder) {
  if (!remainder) {
    return false;
  }
  return !(new RegExp('^<\/' + tagName, 'i')).test(remainder);
};

openPlaceholder = /^([\s\S]*?)(\{{1,3})([\s\S]*)/;

placeholderContent = /^\s*([\#\/]?)(?:(else\sif|if|else|unless|each|with|unescaped)(?!\())?\s*([^\s(>]*(?:\s*\([\s\S]*\))?)(?:\s+as\s+:([^\s>]+))?/;

exports.extractPlaceholder = extractPlaceholder = function(text) {
  var bound, content, end, endInner, escaped, inner, macro, match, name, open, openLen, post, pre, remainder, type;
  if (!(match = openPlaceholder.exec(text))) {
    return;
  }
  pre = match[1];
  open = match[2];
  remainder = match[3];
  openLen = open.length;
  bound = openLen === 1;
  macro = openLen === 3;
  end = matchBraces(remainder, openLen, 0, '{', '}');
  endInner = end - openLen;
  inner = remainder.slice(0, endInner);
  post = remainder.slice(end);
  if (!(content = placeholderContent.exec(inner))) {
    return;
  }
  type = content[2];
  escaped = true;
  if (type === 'unescaped') {
    escaped = false;
    type = '';
  }
  name = content[3];
  if (bound) {
    name = name.replace(/\bthis\b/, '.');
  }
  if (macro && name === 'content') {
    escaped = false;
  }
  return {
    pre: trim(pre),
    post: trim(post),
    bound: bound,
    macro: macro,
    hash: content[1],
    escaped: escaped,
    type: type,
    name: name,
    alias: content[4]
  };
};

matchBraces = function(text, num, i, openChar, closeChar) {
  var close, hasClose, hasOpen, open;
  i++;
  while (num) {
    close = text.indexOf(closeChar, i);
    open = text.indexOf(openChar, i);
    hasClose = ~close;
    hasOpen = ~open;
    if (hasClose && (!hasOpen || (close < open))) {
      i = close + 1;
      num--;
      continue;
    } else if (hasOpen) {
      i = open + 1;
      num++;
      continue;
    } else {
      return;
    }
  }
  return i;
};

fnCall = /^([^(]+)\s*\(\s*([\s\S]*?)\s*\)\s*$/;

argSeparator = /\s*([,(])\s*/g;

notSeparator = /[^,\s]/g;

fnCallError = function(name) {
  throw new Error('malformed view function call: ' + name);
};

fnArgs = function(inner) {
  var args, end, last, lastIndex, match;
  args = [];
  lastIndex = 0;
  while (match = argSeparator.exec(inner)) {
    if (match[1] === '(') {
      end = matchBraces(inner, 1, argSeparator.lastIndex, '(', ')');
      args.push(inner.slice(lastIndex, end));
      notSeparator.lastIndex = end;
      lastIndex = argSeparator.lastIndex = notSeparator.test(inner) ? notSeparator.lastIndex - 1 : end;
      continue;
    }
    args.push(inner.slice(lastIndex, match.index));
    lastIndex = argSeparator.lastIndex;
  }
  if (last = inner.slice(lastIndex)) {
    args.push(last);
  }
  return args;
};

fnArgValue = function(view, ctx, model, name, macro, arg) {
  var firstChar, match;
  if (arg === 'null') {
    return null;
  }
  if (arg === 'true') {
    return true;
  }
  if (arg === 'false') {
    return false;
  }
  firstChar = arg.charAt(0);
  if (firstChar === "'") {
    if (!(match = /^'(.*)'$/.exec(arg))) {
      fnCallError(name);
    }
    return match[1];
  }
  if (firstChar === '"') {
    if (!(match = /^"(.*)"$/.exec(arg))) {
      fnCallError(name);
    }
    return match[1];
  }
  if (/^[\d\-]/.test(firstChar) && !isNaN(arg)) {
    return +arg;
  }
  if (firstChar === '[' || firstChar === '{') {
    throw new Error('object literals not supported in view function call: ' + name);
  }
  return dataValue(view, ctx, model, arg, macro);
};

fnValue = function(view, ctx, model, name, macro) {
  var arg, args, fn, fnName, i, match, _i, _len;
  if (!(match = fnCall.exec(name))) {
    fnCallError(name);
  }
  fnName = match[1];
  args = fnArgs(match[2]);
  for (i = _i = 0, _len = args.length; _i < _len; i = ++_i) {
    arg = args[i];
    args[i] = fnArgValue(view, ctx, model, name, macro, arg);
  }
  if (!(fn = view.getFns[fnName])) {
    throw new Error('view function "' + fnName + '" not found for call: ' + name);
  }
  return fn.apply(null, args);
};

notPathArg = /(?:^['"\d\-[{])|(?:^null$)|(?:^true$)|(?:^false$)/;

exports.pathFnArgs = pathFnArgs = function(name, paths) {
  var arg, args, match, _i, _len;
  if (paths == null) {
    paths = [];
  }
  if (!(match = fnCall.exec(name))) {
    fnCallError(name);
  }
  args = fnArgs(match[2]);
  for (_i = 0, _len = args.length; _i < _len; _i++) {
    arg = args[_i];
    if (notPathArg.test(arg)) {
      continue;
    }
    if (~arg.indexOf('(')) {
      pathFnArgs(arg, paths);
      continue;
    }
    paths.push(arg);
  }
  return paths;
};

_ctxPath = function(ctx, name, noReplace) {
  var aliasName, firstChar, i, indices;
  firstChar = name.charAt(0);
  if (firstChar === ':') {
    if (~(i = name.indexOf('.'))) {
      aliasName = name.slice(1, i);
      name = name.slice(i);
    } else {
      aliasName = name.slice(1);
      name = '';
    }
    i = ctx.$depth - ctx.$aliases[aliasName];
    if (i !== i) {
      throw new Error("Can't find alias for " + aliasName);
    }
  } else if (firstChar === '.') {
    i = 0;
    while (name.charAt(i) === '.') {
      i++;
    }
    name = i === name.length ? '' : name.slice(i - 1);
  }
  if (i && (name = ctx.$paths[i - 1] + name) && !noReplace) {
    indices = ctx.$indices;
    i = indices.length;
    name = name.replace(/\$#/g, function() {
      return indices[--i];
    });
  }
  return name.replace(/\[([^\]]+)\]/g, function(match, name) {
    return lookup(name, ctx);
  });
};

exports.ctxPath = ctxPath = function(ctx, name, macro, noReplace) {
  var base, macroCtx, macroVar, path, remainder, value, _ref;
  if (macro) {
    macroCtx = ctx.$macroCtx;
    path = _ctxPath(macroCtx, name, noReplace);
    _ref = path.split('.'), base = _ref[0], remainder = _ref[1];
    value = lookup(base, macroCtx);
    if (!(value && (macroVar = value.$macroVar))) {
      return path;
    }
    name = remainder ? (/\.+/.test(macroVar) ? macroVar.slice(1) : macroVar) + '.' + remainder : macroVar;
  }
  return _ctxPath(ctx, name, noReplace);
};

exports.dataValue = dataValue = function(view, ctx, model, name, macro) {
  var base, macroCtx, macroVar, path, remainder, value, _ref;
  if (~name.indexOf('(')) {
    return fnValue(view, ctx, model, name, macro);
  }
  if (macro) {
    macroCtx = ctx.$macroCtx;
    path = _ctxPath(macroCtx, name);
    _ref = path.split('.'), base = _ref[0], remainder = _ref[1];
    value = lookup(base, macroCtx);
    if (value && (macroVar = value.$macroVar)) {
      name = remainder ? (/\.+/.test(macroVar) ? macroVar.slice(1) : macroVar) + '.' + remainder : macroVar;
      path = _ctxPath(ctx, name);
      value = lookup(path, ctx);
    }
  } else {
    path = _ctxPath(ctx, name);
    value = lookup(path, ctx);
  }
  if (value !== void 0) {
    if (typeof value === 'function') {
      return value(ctx, model);
    } else {
      return value;
    }
  }
  value = model.get(path);
  if (value !== void 0) {
    return value;
  } else {
    return model[path];
  }
};

exports.setBoundFn = setBoundFn = function(view, ctx, model, name, value) {
  var arg, args, fnName, get, i, inputs, macro, match, numInputs, out, path, set, _i, _len;
  if (!(match = fnCall.exec(name))) {
    fnCallError(name);
  }
  fnName = match[1];
  args = fnArgs(match[2]);
  if (!((get = view.getFns[fnName]) && (set = view.setFns[fnName]))) {
    throw new Error('view function "' + fnName + '" not found for binding to: ' + name);
  }
  macro = false;
  numInputs = set.length - 1;
  if (numInputs) {
    inputs = [value];
    i = 0;
    while (i < numInputs) {
      inputs.push(fnArgValue(view, ctx, model, name, macro, args[i++]));
    }
    out = set.apply(null, inputs);
  } else {
    out = set(value);
  }
  if (!out) {
    return;
  }
  for (i = _i = 0, _len = out.length; _i < _len; i = ++_i) {
    value = out[i];
    arg = args[i + numInputs];
    if (~arg.indexOf('(')) {
      setBoundFn(view, ctx, model, arg, value);
      continue;
    }
    if (value === void 0 || notPathArg.test(arg)) {
      continue;
    }
    path = ctxPath(ctx, arg);
    if (model.get(path) === value) {
      continue;
    }
    model.set(path, value);
  }
};
