// Generated by CoffeeScript 1.3.1
var AUTOCOMPLETE_OFF, TEXT_EVENTS, addDomEvent, containsEvent, ctxPath, merge, onBindA, onBindForm, pathFnArgs, setBoundFn, splitEvents, _ref;

merge = require('racer/lib/util').merge;

_ref = require('./viewPath'), ctxPath = _ref.ctxPath, pathFnArgs = _ref.pathFnArgs, setBoundFn = _ref.setBoundFn;

module.exports = {
  bound: {
    'value': {
      'input': function(events, attrs, name) {
        var eventNames, method;
        if (attrs.type === 'radio') {
          return;
        }
        if ('x-blur' in attrs) {
          delete attrs['x-blur'];
          eventNames = 'change,blur';
        } else {
          eventNames = TEXT_EVENTS;
        }
        if ('x-ignore-focus' in attrs) {
          delete attrs['x-ignore-focus'];
          method = 'prop';
        } else {
          method = 'propPolite';
        }
        addDomEvent(events, attrs, eventNames, name, {
          method: 'prop',
          property: 'value'
        });
        return {
          method: method
        };
      }
    },
    'checked': {
      '*': function(events, Â attrs, name) {
        addDomEvent(events, attrs, 'change', name, {
          method: 'prop',
          property: 'checked'
        });
        return {
          method: 'prop',
          bool: true
        };
      }
    },
    'selected': {
      '*': function(events, attrs, name) {
        addDomEvent(events, attrs, 'change', name, {
          method: 'prop',
          property: 'selected'
        });
        return {
          method: 'prop',
          bool: true
        };
      }
    },
    'disabled': {
      '*': function() {
        return {
          method: 'prop',
          bool: true
        };
      }
    }
  },
  boundParent: {
    'contenteditable': {
      '*': function(events, attrs, name) {
        addDomEvent(events, attrs, TEXT_EVENTS, name, {
          method: 'html'
        });
      }
    }
  },
  element: {
    'select': function(events, attrs) {
      addDomEvent(events, attrs, 'change:$forChildren');
      return {
        addId: true
      };
    },
    'input': function(events, attrs) {
      if (AUTOCOMPLETE_OFF[attrs.type] && !('autocomplete' in attrs)) {
        attrs.autocomplete = 'off';
      }
      if (attrs.type === 'radio') {
        addDomEvent(events, attrs, 'change:$forName');
      }
    }
  },
  attr: {
    'x-bind': {
      '*': function(events, attrs, eventNames) {
        addDomEvent(events, attrs, eventNames);
        return {
          addId: true,
          del: true
        };
      },
      'a': onBindA = function(events, attrs, eventNames) {
        if (containsEvent(eventNames, 'click') && !('href' in attrs)) {
          attrs.href = '#';
          if (!('onclick' in attrs)) {
            attrs.onclick = 'return false';
          }
        }
      },
      'form': onBindForm = function(events, attrs, eventNames) {
        if (containsEvent(eventNames, 'submit')) {
          if (!('onsubmit' in attrs)) {
            attrs.onsubmit = 'return false';
          }
        }
      }
    },
    'x-capture': {
      '*': function(events, attrs, eventNames) {
        addDomEvent(events, attrs, eventNames, null, {
          capture: true
        });
        return {
          addId: true,
          del: true
        };
      },
      'a': onBindA,
      'form': onBindForm
    }
  },
  TEXT_EVENTS: TEXT_EVENTS = 'keyup,keydown,paste/0,dragover/0,blur',
  AUTOCOMPLETE_OFF: AUTOCOMPLETE_OFF = {
    checkbox: true,
    radio: true
  },
  splitEvents: splitEvents = function(eventNames) {
    var delay, fn, name, out, pair, pairs, segments, _i, _len, _ref1;
    pairs = eventNames.replace(/\s/g, '').split(',');
    out = [];
    for (_i = 0, _len = pairs.length; _i < _len; _i++) {
      pair = pairs[_i];
      segments = pair.split(':');
      _ref1 = segments[0].split('/'), name = _ref1[0], delay = _ref1[1];
      fn = segments[1] || '';
      out.push([name, delay, fn]);
    }
    return out;
  },
  containsEvent: containsEvent = function(eventNames, expected) {
    var eventName, _i, _len, _ref1;
    _ref1 = splitEvents(eventNames);
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      eventName = _ref1[_i][0];
      if (eventName === expected) {
        return true;
      }
    }
    return false;
  },
  addDomEvent: addDomEvent = function(events, attrs, eventNames, name, options) {
    var args, eventList;
    eventList = splitEvents(eventNames);
    if (name) {
      if (~name.indexOf('(')) {
        args = pathFnArgs(name);
        if (!args.length) {
          return;
        }
        events.push(function(ctx, modelEvents, dom, pathMap, view) {
          var arg, delay, eventName, id, path, pathId, paths, _i, _j, _len, _len1, _ref1;
          id = attrs._id || attrs.id;
          paths = [];
          options.setValue = function(model, value) {
            return setBoundFn(view, ctx, model, name, value);
          };
          for (_i = 0, _len = args.length; _i < _len; _i++) {
            arg = args[_i];
            path = ctxPath(ctx, arg);
            paths.push(path);
            pathId = pathMap.id(path);
            for (_j = 0, _len1 = eventList.length; _j < _len1; _j++) {
              _ref1 = eventList[_j], eventName = _ref1[0], delay = _ref1[1];
              dom.bind(eventName, id, merge({
                pathId: pathId,
                delay: delay
              }, options));
            }
          }
        });
        return;
      }
      events.push(function(ctx, modelEvents, dom, pathMap) {
        var delay, eventName, id, pathId, _i, _len, _ref1;
        id = attrs._id || attrs.id;
        pathId = pathMap.id(ctxPath(ctx, name));
        for (_i = 0, _len = eventList.length; _i < _len; _i++) {
          _ref1 = eventList[_i], eventName = _ref1[0], delay = _ref1[1];
          dom.bind(eventName, id, merge({
            pathId: pathId,
            delay: delay
          }, options));
        }
      });
      return;
    }
    return events.push(function(ctx, modelEvents, dom) {
      var delay, eventName, fn, id, _i, _len, _ref1;
      id = attrs._id || attrs.id;
      for (_i = 0, _len = eventList.length; _i < _len; _i++) {
        _ref1 = eventList[_i], eventName = _ref1[0], delay = _ref1[1], fn = _ref1[2];
        dom.bind(eventName, id, merge({
          fn: fn,
          delay: delay
        }, options));
      }
    });
  }
};
